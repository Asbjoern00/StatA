lapply(data_sets, mean)
data_sets
data_sets[1]
data_sets[,1]
data_sets[,2]
data_sets[,3]
data_sets[[1]]
data_sets
data_sets[[0]]
data_sets[1]
data_sets[1][1]
data_sets[1][[1]]
data_sets[2][[1]]
data_sets[2][[2]]
VarCorr(mod_REML)
VarCorr(mod_REML) %>% tibble()
VarCorr(mod_REML) %>% data.frame() %>%  tibble()
VarCorr(mod_REML) %>% data.frame() %>%  tibble()
VarCorr(mod_REML) %>% data.frame() %>%  tibble() %>% select(grp, sdcor)
VarCorr(mod_REML) %>% data.frame() %>%  tibble() %>% select(grp, sdcor) %>% mutate(type = "REML")
get_sd_estim <- function(dataset){
#Update response
satData$math <- dataset[[1]]
#Fit models
mod_REML <- lmer(math ~ year + (1|tchrid) + (1|studid), data = satData)
mod_ML <- lmer(math ~ year + (1|tchrid) + (1|studid), data = satData, REML = FALSE)
# Get dataframes for params
reml <- VarCorr(mod_REML) %>% data.frame() %>%  tibble() %>%
select(grp, sdcor) %>% mutate(type = "REML")
ml <- VarCorr(mod_REML) %>% data.frame() %>%  tibble() %>%
select(grp, sdcor) %>% mutate(type = "ML")
return(bind_rows(reml,ml))
}
lapply(data_sets, get_sd_estim)
satData_copy <- satData
# Simulate n = 2000 datasets
data_sets <- simulate(mod_ML, 2000)
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
library(ggplot2)
library(dplyr)
library(lme4)
library(LabApplStat)
library(readr)
setwd("~/Desktop/statA/MM")
satData <- read_csv("sat.csv",skip = 1) %>% mutate(studid = as.factor(studid), tchrid = as.factor(tchrid), year = as.factor(year))
satData %>% group_by(studid) %>% count() %>% nrow() # 122 students
satData %>% group_by(tchrid) %>% count() %>% nrow() # 12 teachers
satData %>% group_by(studid) %>% count() %>% ungroup() %>% summarise(mean(n))
table(satData$tchrid, satData$year)
plot(DD(~studid+tchrid + year,  data = satData))
mod <- lmer(math ~ year + (1|tchrid) + (1|studid), data = satData)
summary(mod)
mod %>% confint()
drop1(mod, test = "Chisq")
satData_mod <- satData
satData_mod$year <- factor(satData_mod$year, levels = c("0","-1","1"))
mod_contr <- lmer(math ~ year + (1|tchrid) + (1|studid), data = satData_mod)
mod_contr %>% confint()
mod_REML <- lmer(math ~ year + (1|tchrid) + (1|studid), data = satData)
mod_ML <- lmer(math ~ year + (1|tchrid) + (1|studid), data = satData, REML = FALSE)
summary(mod_REML)
summary(mod_ML)
# Simulate n = 2000 datasets
data_sets <- simulate(mod_ML, 2000)
satData_copy <- satData
satData
data_sets[1]
dataset <- data_sets[1]
#Update response
satData_copy$math <- dataset[[1]]
satData_copy
#Fit models
mod_REML <- lmer(math ~ year + (1|tchrid) + (1|studid), data = satData_copy)
mod_ML <- lmer(math ~ year + (1|tchrid) + (1|studid), data = satData_copy, REML = FALSE)
# Get dataframes for params
reml <- VarCorr(mod_REML) %>% data.frame() %>%  tibble() %>%
select(grp, sdcor) %>% mutate(type = "REML")
ml <- VarCorr(mod_REML) %>% data.frame() %>%  tibble() %>%
select(grp, sdcor) %>% mutate(type = "ML")
reml
ml
# Simulate n = 200 datasets
data_sets <- simulate(mod_ML, 200)
satData_copy <- satData
get_sd_estim <- function(dataset){
#Update response
satData_copy$math <- dataset[[1]]
#Fit models
mod_REML <- lmer(math ~ year + (1|tchrid) + (1|studid), data = satData_copy)
mod_ML <- lmer(math ~ year + (1|tchrid) + (1|studid), data = satData_copy, REML = FALSE)
# Get dataframes for params
reml <- VarCorr(mod_REML) %>% data.frame() %>%  tibble() %>%
select(grp, sdcor) %>% mutate(type = "REML")
ml <- VarCorr(mod_ML) %>% data.frame() %>%  tibble() %>%
select(grp, sdcor) %>% mutate(type = "ML")
return(bind_rows(reml,ml))
}
lapply(data_sets, get_sd_estim)
for(dataset in data_sets){
test <- get_sd_estim(dataset)
}
# Simulate n = 200 datasets
data_sets <- simulate(mod_ML, 200)
satData_copy <- satData
get_sd_estim <- function(dataset){
#Update response
satData_copy$math <- dataset[[1]]
#Fit models
mod_REML <- lmer(math ~ year + (1|tchrid) + (1|studid), data = satData_copy)
mod_ML <- lmer(math ~ year + (1|tchrid) + (1|studid), data = satData_copy, REML = FALSE)
# Get dataframes for params
reml <- VarCorr(mod_REML) %>% data.frame() %>%  tibble() %>%
select(grp, sdcor) %>% mutate(type = "REML")
ml <- VarCorr(mod_ML) %>% data.frame() %>%  tibble() %>%
select(grp, sdcor) %>% mutate(type = "ML")
return(bind_rows(reml,ml))
}
res <- lapply(data_sets, get_sd_estim)
res
res[[1]]
satData_copy
dataset[[1]]
dataset[1]
dataset
get_sd_estim <- function(dataset){
#Update response
satData_copy$math <- dataset
#Fit models
mod_REML <- lmer(math ~ year + (1|tchrid) + (1|studid), data = satData_copy)
mod_ML <- lmer(math ~ year + (1|tchrid) + (1|studid), data = satData_copy, REML = FALSE)
# Get dataframes for params
reml <- VarCorr(mod_REML) %>% data.frame() %>%  tibble() %>%
select(grp, sdcor) %>% mutate(type = "REML")
ml <- VarCorr(mod_ML) %>% data.frame() %>%  tibble() %>%
select(grp, sdcor) %>% mutate(type = "ML")
return(bind_rows(reml,ml))
}
res <- lapply(data_sets, get_sd_estim)
res
do.call(res, bind_rows())
bind_rows(res)
# Simulate n = 2000 datasets
data_sets <- simulate(mod_ML, 2000)
satData_copy <- satData
get_sd_estim <- function(dataset){
#Update response
satData_copy$math <- dataset
#Fit models
mod_REML <- lmer(math ~ year + (1|tchrid) + (1|studid), data = satData_copy)
mod_ML <- lmer(math ~ year + (1|tchrid) + (1|studid), data = satData_copy, REML = FALSE)
# Get dataframes for params
reml <- VarCorr(mod_REML) %>% data.frame() %>%  tibble() %>%
select(grp, sdcor) %>% mutate(type = "REML")
ml <- VarCorr(mod_ML) %>% data.frame() %>%  tibble() %>%
select(grp, sdcor) %>% mutate(type = "ML")
return(bind_rows(reml,ml))
}
res <- lapply(data_sets, get_sd_estim) %>% bind_rows()
res
res %>% group_by(grp, type) %>% summarise(mean)
res %>% group_by(grp, type) %>% summarise(mean(sdcor))
res %>% group_by(grp, type) %>% summarise(estim = mean(sdcor))
VarCorr()
VarCorr(mod_ML)
VarCorr(mod_ML) %>% tibble()
VarCorr(mod_ML) %>% data.frame() %>% tibble()
VarCorr(mod_ML) %>% data.frame() %>% tibble() %>% select(grp, sdcor)
VarCorr(mod_ML) %>% data.frame() %>% tibble() %>% select(grp, sdcor) %>% rename(sdcor = "true")
VarCorr(mod_ML) %>% data.frame() %>% tibble() %>% select(grp, sdcor) %>% rename(true = "sdcor")
estims <- res %>% group_by(grp, type) %>% summarise(estim = mean(sdcor))
left_join(estims, parms)
parms <- VarCorr(mod_ML) %>% data.frame() %>% tibble() %>% select(grp, sdcor) %>% rename(true = "sdcor")
left_join(estims, parms)
compare <- left_join(estims, parms) %>% mutate(abs_dev = abs(estim-true))
compare
res
res %>% ggplot(aes(x = sdcor)) +geom_histogram()
res %>% ggplot(aes(x = sdcor)) + geom_histogram() +theme_bw()
res
res %>% ggplot(aes(x = sdcor)) + geom_histogram() + facet_wrap(~grp+type) + theme_bw()
res %>% ggplot(aes(x = sdcor)) + geom_histogram() + facet_wrap(~type+grp) + theme_bw()
confint(mod_ML)
confint(mod_ML, type = "Wald")
confint(mod_ML, method = "Wald")
confint(mod_ML, method = "Wald") %>% tibble()
confint(mod_ML, method = "Wald") %>% data.frame() %>% tibble()
confint(mod_ML, method = "Wald")
confint(mod_ML, method = "Wald")[,1]
confint(mod_ML, method = "Wald")[,2]
mod_ML
mod_ML %>% fixef()
ML_param <- mod_ML %>% fixef()
REML_param <- mod_REML %>% fixef()
ML_param
confint(mod_ML, method = "Wald")[,1]
confint(mod_ML, method = "Wald")[,1][names(ML_param)]
confint(mod_ML, method = "Wald")[,1][names(ML_param)] <= ML_param
dataset
#Update response
satData_copy$math <- dataset
#Fit models
mod_REML <- lmer(math ~ year + (1|tchrid) + (1|studid), data = satData_copy)
mod_ML <- lmer(math ~ year + (1|tchrid) + (1|studid), data = satData_copy, REML = FALSE)
#Check contained in confidence intervals
ml_low <- confint(mod_ML, method = "Wald")[,1][names(ML_param)] <= ML_param
ml_high <- confint(mod_ML, method = "Wald")[,2][names(ML_param)] <= ML_param
reml_high <- confint(mod_REML, method = "Wald")[,2][names(ML_param)] >= ML_param
ml_res <- ml_low*ml_high
reml_res <- reml_low*reml_high
reml_low <- confint(mod_REML, method = "Wald")[,1][names(ML_param)] >= ML_param
reml_res <- reml_low*reml_high
ml_res
#Check contained in confidence intervals
ml_low <- confint(mod_ML, method = "Wald")[,1][names(ML_param)] <= ML_param
ml_high <- confint(mod_ML, method = "Wald")[,2][names(ML_param)] <= ML_param
reml_low <- confint(mod_REML, method = "Wald")[,1][names(ML_param)] >= ML_param
reml_high <- confint(mod_REML, method = "Wald")[,2][names(ML_param)] >= ML_param
ml_low
ml_high
ml_high
confint(mod_ML, method = "Wald")[,2][names(ML_param)]
ML_param
ml_low <- confint(mod_ML, method = "Wald")[,1][names(ML_param)] <= ML_param
ml_high <- confint(mod_ML, method = "Wald")[,2][names(ML_param)] >= ML_param
reml_low <- confint(mod_REML, method = "Wald")[,1][names(ML_param)] <= ML_param
reml_high <- confint(mod_REML, method = "Wald")[,2][names(ML_param)] >= ML_param
ml_res <- ml_low*ml_high
ml_res
reml_res <- reml_low*reml_high
reml_res
reml_res %>% tibble()
res
ml_res
df_ml <- tibble(covers = ml_res, parameter = names(ml_res), type = "ML")
df_reml <- tibble(covers = reml_res, parameter = names(reml_res), type = "REML")
df_ml
bind_rows(df_ml, df_reml)
df_ml <- tibble(covers = ml_res, parameter = names(ml_res), type = "ML")
df_reml <- tibble(covers = reml_res, parameter = names(reml_res), type = "REML")
bind_rows(df_ml, df_reml)
abe <- bind_rows(df_ml, df_reml)
abe
ML_param <- mod_ML %>% fixef()
REML_param <- mod_REML %>% fixef()
get_coverage_estim <- function(dataset){
#Update response
satData_copy$math <- dataset
#Fit models
mod_REML <- lmer(math ~ year + (1|tchrid) + (1|studid), data = satData_copy)
mod_ML <- lmer(math ~ year + (1|tchrid) + (1|studid), data = satData_copy, REML = FALSE)
#Check contained in confidence intervals
ml_confint <- confint(mod_ML, method = "Wald")
ml_low <- ml_confint[,1][names(ML_param)] <= ML_param
ml_high <- ml_confint[,2][names(ML_param)] >= ML_param
reml_confint <- confint(mod_REML, method = "Wald")
reml_low <- reml_confint[,1][names(ML_param)] <= ML_param
reml_high <- reml_confint[,2][names(ML_param)] >= ML_param
ml_res <- ml_low*ml_high
reml_res <- reml_low*reml_high
df_ml <- tibble(covers = ml_res, parameter = names(ml_res), type = "ML")
df_reml <- tibble(covers = reml_res, parameter = names(reml_res), type = "REML")
return(bind_rows(df_ml, df_reml))
}
cov_res <- lapply(data_sets, get_sd_estim) %>% bind_rows()
#compute the coverage
estim_cov <- cov_res %>% group_by(type,parameter) %>% summarize(coverage = mean(covers))
cov_res
cov_res <- lapply(data_sets, get_coverage_estim) %>% bind_rows()
cov_res
#compute the coverage
estim_cov <- cov_res %>% group_by(type,parameter) %>% summarize(coverage = mean(covers))
estim_cov
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
library(ggplot2)
library(dplyr)
library(lme4)
setwd("~/Desktop/statA/MM")
load("tvdata.Rdata")
mydata <- select(TVbo, Assessor, TVset, Picture, Sharpnessofmovement)
mydata <- mutate(mydata, Product=TVset:Picture, Pair=Assessor:Product)
mydata %>% summary()
meanData1 <- mydata %>%
group_by(Assessor,Picture,TVset) %>%
summarize(m=mean(Sharpnessofmovement))
meanData1 %>%
ggplot(aes(x=Picture:TVset, y=m, group=Assessor, col=Assessor)) +
geom_line()
library(LabApplStat)
dd <- DD(~TVset + Picture + Assessor + Pair, data = mydata)
plot(dd)
lmer1 <- lmer(Sharpnessofmovement ~ TVset+Picture + (1|Assessor) +(1|Pair),
data=mydata)
lmer1 %>% plot()
summary(lmer1)
\rho = \frac{2.174 + 1.380}{7.286} = 0.49
pbeta(0.025, 211,49)
1beta(0.025, 211,49)
qbeta(0.025, 211,49)
qbeta(0.975, 211,49)
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
library(ggplot2)
library(dplyr)
library(lme4)
library(LabApplStat)
library(readr)
library(gridExtra)
setwd("/home/asr/Desktop/statA/MM")
load("epiData.Rdata")
epiData <- epiData %>% tibble()
grid.arrange(
epiData %>% group_by(period, drug) %>%
summarize(MeanPerWeek = mean(seizures/timeadj)) %>%
ggplot(aes(x=period,y=MeanPerWeek, col=drug)) +
geom_line(size = 1.2, aes(group = drug, color = drug)) +
geom_point(size = 2.6, aes(color = drug)),
epiData %>% group_by(id) %>%
ggplot(aes(x=period,y=(seizures/timeadj), col=drug)) +
geom_line(size = 1, aes(group = id, color = drug)) +
geom_point(size = 1.5, aes(color = drug)) + facet_wrap(~drug) +
theme(legend.position = "none")
)
epiData1 <- filter(epiData, period>0)
glmer1 <- glmer(seizures ~ age + drug + log(baseline) + (1|id),
family="poisson", data=epiData1)
glmer1 %>% drop1(test = "Chisq")
grid.arrange(
epiData %>% group_by(period, drug) %>%
summarize(MeanPerWeek = mean(seizures/timeadj)) %>%
ggplot(aes(x=period,y=MeanPerWeek, col=drug)) +
geom_line(size = 1.2, aes(group = drug, color = drug)) +
geom_point(size = 2.6, aes(color = drug)),
epiData %>% group_by(id) %>%
ggplot(aes(x=period,y=(seizures/timeadj), col=drug)) +
geom_line(size = 1, aes(group = id, color = drug)) +
geom_point(size = 1.5, aes(color = drug)) + facet_wrap(~drug) +
theme(legend.position = "none")
)
summary(glmer3)
glmer3 <- glmer(seizures ~ offset(log(timeadj)) + period + age + phase*drug + (1|id),
family="poisson", data=epiData)
summary(glmer3)
lmer2 <- lmer(seizures/timeadj ~ age + phase*drug + (1|id), data=epiData)
lmer2 %>% plot()
lmer(sqrt(seizures/timeadj) ~ age + phase*drug + (1|id), data=epiData) %>% plot()
lmer(sqrt(seizures/timeadj) ~ age + phase*drug + (1|id), data=epiData) %>% plot()
lmer(sqrt(seizures/timeadj) ~ age + phase*drug + (1|id), data=epiData) %>% summary()
mu1 <- ((1/tau0^2)*mu0 + (1/sigma^2)*y ) / ( 1/tau^2 + 1/sigma^2  )
tau0 <- 20
mu0 <- 370
sigma <- 8
y <- 421
mu1 <- ((1/tau0^2)*mu0 + (1/sigma^2)*y ) / ( 1/tau^2 + 1/sigma^2  )
mu1 <- ((1/tau0^2)*mu0 + (1/sigma^2)*y ) / ( 1/tau0^2 + 1/sigma^2  )
mu1
tau1 <- ( 1/tau0^2 + 1/sigma^2  )
1/tau1
tau1 <- sqrt(1/( 1/tau0^2 + 1/sigma^2  ))
tau1
qnorm(0.025,mean = mu1, sd = tau1)
qnorm(0.975,mean = mu1, sd = tau1)
421-8*1.96
421+8*1.96
tau0 <- 50
mu0 <- 400
sigma <- 8
y <- 421
mu1 <- ((1/tau0^2)*mu0 + (1/sigma^2)*y ) / ( 1/tau0^2 + 1/sigma^2  )
mu1
tau1 <- sqrt(1/( 1/tau0^2 + 1/sigma^2  ))
tau1
tau0 <- 50
mu0 <- 400
sigma <- 8
y <- 421
mu1 <- ((1/tau0^2)*mu0 + (1/sigma^2)*y ) / ( 1/tau0^2 + 1/sigma^2  )
mu1
tau1 <- sqrt(1/( 1/tau0^2 + 1/sigma^2  ))
qnorm(0.975,mean = mu1, sd = tau1)
qnorm(0.025,mean = mu1, sd = tau1)
rm(list = ls())
library(rstan)
example(stan_model, package = "rstan", run.dontrun = TRUE)
Sys.setenv(DOWNLOAD_STATIC_LIBV8 = 1)
install.packages("V8")
example(stan_model, package = "rstan", run.dontrun = TRUE)
remove.packages("rstan")
remove("rstan")
library(rstan)
remove.packages("rstan", lib="/usr/lib/R/site-library")
remove.packages("rstan", lib="/usr/lib/R/site-library")
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
library(V8)
example(v8)
Sys.setenv(DOWNLOAD_STATIC_LIBV8 = 1) # only necessary for Linux without the nodejs library / headers
install.packages("rstan", repos = "https://cloud.r-project.org/", dependencies = TRUE)
remove.packages(c("StanHeaders", "rstan"))
install.packages("rstan", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
Sys.setenv(TBB_VERSION="2021.1.1")
Sys.setenv(TBB="/opt/intel/oneapi/tbb/2021.1.1")
Sys.setenv(TBB_INC="/opt/intel/oneapi/tbb/2021.1.1/include")
Sys.setenv(TBB_LIB="/opt/intel/oneapi/tbb/2021.1.1/lib")
Sys.setenv(TBB_INTERFACE_NEW ="true")
remotes::install_github("RcppCore/RcppParallel", force = TRUE)
remotes::install_github("hsbadr/rstan/StanHeaders@develop", force = TRUE)
example(stan_model, package = "rstan", run.dontrun = TRUE)
m <- 10000
p0 <- rbeta(m, y0+1, n0-y0+1)
p1 <- rbeta(m, y1+1, n1-y1+1)
# 2.
# Draw simulated values from correct beta distributions. Since density factors, we can simulate from the joint posterior by simulating from the marginal betas
n0 <- 674
y0 <- 39
n1 <- 680
y1 <- 22
m <- 10000
p0 <- rbeta(m, y0+1, n0-y0+1)
p1 <- rbeta(m, y1+1, n1-y1+1)
#
OR <- (p1/(1-p1)) / (p0/(1-p0))
post_mean <- mean(OR)
post_men
post_mean
quantile(OR)
quantile(OR, c(0.025,0.975))
# 2.
# Draw simulated values from correct beta distributions. Since density factors, we can simulate from the joint posterior by simulating from the marginal betas
n0 <- 674
y0 <- 39
n1 <- 680
y1 <- 22
m <- 10000
p0 <- rbeta(m, y0+1, n0-y0+1)
p1 <- rbeta(m, y1+1, n1-y1+1)
# 3.
OR <- (p1/(1-p1)) / (p0/(1-p0))
mean(OR) # Posterior mean
quantile(OR, c(0.025,0.975)) # Posterior credible interval
# We see that 1 is not covered by the confidence interval, so we would say that there is less risk of death in the treatment group
#4. We saw that the marginal posteriors are Beta(y_i,n_i-y_i) hence
p0 <- rbeta(m, y0, n0-y0)
p1 <- rbeta(m, y1, n1-y1)
OR <- (p1/(1-p1)) / (p0/(1-p0))
mean(OR) # Posterior mean
quantile(OR, c(0.025,0.975)) # Posterior credible interval
getwd()
setwd("~/Desktop/statA/BS")
setwd("~/Desktop/statA/BS")
load("mandatory3.Rdata")
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())
library(ggplot2)
library(dplyr)
setwd("~/Desktop/statA/BS")
load("mandatory3.Rdata")
after <- subset(vanData, law==0)
after
after
glm(y ~ 1, family = poisson(), data = after)
glm(y ~ 1, family = poisson(link = "identity"), data = after)
exp(2.26)
glm(y ~ 1, family = poisson(), data = after)
glm(y ~ 1, family = poisson(), data = after) %>% coef()
glm(y ~ 1, family = poisson(), data = after) %>% coef() %>% exp()
confint(fitted)
fitted <- glm(y ~ 1, family = poisson(), data = after)
confint(fitted)
exp(confint(fitted))
exp(confint(fitted))
after
ybar <- after$y %>% mean()
ybar
n <- length(after)
n <- nrow(after)
rgamma(m, n*ybar+1, n)
m <- 10000
rgamma(m, n*ybar+1, n)
lambda_sim <- rgamma(m, n*ybar+1, n)
mean(lambda_sim)
tibble(mean = lambda_sim %>% mean())
print(mean(lambda_sim), quantile(lambda_sim, c(0.025, 0.975)))
quantile(lambda_sim, c(0.025, 0.975))
rpois(m, lambda_sim)
quantile(rpois(m, lambda_sim), c(0.01,0.05))
quantile(rpois(m, 23*lambda_sim), c(0.01,0.05))
quantile(rpois(m, 23*lambda_sim), c(0.001,0.01,0.05))
library(brms)
install.packages("brms")
library(rstan)
remove.packages(c("StanHeaders", "rstan"))
install.packages("rstan", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
install.packages("rstan", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
remove.packages("rstan")
if (file.exists(".RData")) file.remove(".RData")
library(rstan)
library("rstan")
remove.packages("rstan", lib="/usr/lib/R/site-library")
library(rstan)
remove.packages("rstan")
.libPaths()
library(stan)
install.packages("stan")
install.packages("rstan")
remove.packages("rstan")
remove.packages("rstan", lib = "/usr/local/lib/R/site-library"  )
remove.packages("rstan", lib = /usr/lib/R/site-library"  )
remove.packages("rstan", lib = "/usr/lib/R/site-library"  )
install.packages("brms")
.libPaths()
